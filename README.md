# Pneumonia Detection Model

이 프로젝트는 흉부 X-ray 영상을 분석하여 폐렴 여부를 예측하는 모델을 학습하기 위해 ResNet50을 사용합니다. 세 가지 접근 방식을 통해 모델 성능을 비교하고, 더 나은 성능을 제공하는 방법을 찾습니다.

## 같이 프로젝트 한사람
-전북대학교 통계학과 강건우

## 주요 내용 소개

이 코드에서는 사전 학습된 **ResNet50**을 사용하여 흉부 X-ray 이미지를 분석합니다. **Focal Loss**와 **AdamW 옵티마이저**, 그리고 **Cosine Annealing** 학습률 스케줄러를 사용하여 모델을 학습합니다. 각 부분에 대한 세부 설명은 아래와 같습니다.

- **모델 아키텍처**: 사전 학습된 ResNet50을 사용하며, 최종 레이어를 이진 분류를 위해 수정했습니다. 추가적으로 **Dropout** 레이어를 추가하여 과적합을 방지합니다.
- **Focal Loss**: 클래스 불균형 문제를 해결하기 위해 Focal Loss를 사용합니다. `alpha`와 `gamma` 값을 조정하여 양성 샘플에 대한 가중치를 부여하고, 어려운 샘플에 대해 더 많은 가중치를 할당합니다.
- **정확도, 정밀도, 재현율, F1 스코어**: 테스트 셋에 대해 정확도, 정밀도, 재현율, F1 스코어를 계산하여 모델 성능을 평가합니다.
- **학습률 스케줄링**: **Cosine Annealing** 스케줄러를 사용하여 학습률을 점진적으로 줄여가며 모델의 안정적인 학습을 유도합니다.
- **학습률**: 초기 학습률을 0.001로 설정하고, 최소 학습률은 0.00001로 설정하여 학습이 끝날 때까지 점진적으로 감소하도록 설정합니다.
- **조기 종료**: 검증 손실이 개선되지 않는 경우 학습을 일찍 종료하도록 설정했습니다. 이는 불필요한 에포크 수를 줄여 과적합을 방지합니다.

## 데이터 전처리 및 증강

모델 학습을 위해 이미지를 224x224 크기로 조정하고 다양한 증강 기법을 적용했습니다. 이를 통해 모델이 다양한 패턴을 학습하고, 데이터가 부족한 의료 데이터셋에서 과적합을 방지할 수 있도록 합니다.

### 이미지 전처리 및 증강 설정

- **이미지 크기 조정**: 모든 이미지를 `Resize((224, 224))`로 크기를 조정하여 모델 입력 형식에 맞추었습니다.
- **데이터 증강**: 학습 데이터에 `RandomRotation`, `RandomHorizontalFlip`, `RandomAffine`, `ColorJitter` 등을 적용하여 이미지 회전, 좌우 반전, 이동, 밝기/대비 조정을 수행했습니다.
- **텐서 변환 및 정규화**: 이미지를 텐서 형식으로 변환(`ToTensor()`)하고, 각 채널을 정규화(`Normalize()`)하여 안정적인 학습을 지원했습니다.

## 코드 주요 구성 요소

- **ResNet50 모델 아키텍처**: `torchvision.models.resnet50(weights=models.ResNet50_Weights.DEFAULT)`를 사용하여 사전 학습된 가중치를 활용합니다.
  - 출력층은 `nn.Linear(self.model.fc.in_features, 1)`로 변경하여 이진 분류가 가능하도록 수정되었습니다.
  - **Dropout(0.5)** 레이어를 추가하여 학습 과정에서 과적합을 방지합니다.

- **Focal Loss 정의**
  - `alpha=2`, `gamma=1.5`로 설정하여 클래스 불균형 문제를 해결합니다. `alpha`는 양성 샘플에 대한 가중치이며, `gamma`는 예측이 어려운 샘플에 더 많은 가중치를 할당하는 정도를 조절합니다.

- **Optimizer 및 학습률 스케줄러**
  - 옵티마이저로는 **AdamW**를 사용하며, 학습률은 `lr=0.001`로 설정됩니다. **AdamW**는 가중치 감쇠(weight decay)를 추가로 고려하여 과적합을 방지하는 역할을 합니다.
  - 학습률 스케줄러로 **CosineAnnealingLR**을 사용하여 점진적으로 학습률을 감소시킵니다. 이는 모델이 최적의 손실 함수 최소값을 찾는 데 도움이 됩니다.

## 학습 및 평가

- **학습 과정**
  - **에포크 수**: 기본적으로 10번의 에포크 동안 학습하며, 학습 중 검증 손실이 개선되지 않으면 **조기 종료**를 발동하여 학습을 중단할 수 있습니다.
  - 학습 도중 **조기 종료 조건**을 만족하면 `pneumonia_detection_model_optimized.pth` 파일에 가장 성능이 좋은 모델이 저장됩니다.

- **테스트 평가 (Test-Time Augmentation 포함)**
  - 모델은 테스트 단계에서 **Test-Time Augmentation (TTA)**을 적용하여 다양한 각도로 회전된 이미지를 평가하며, 결과를 평균하여 최종 예측을 내립니다.
  - 예측값의 임계값(threshold)은 **0.8**로 설정하여 폐렴 진단에 대한 모델의 신뢰성을 높였습니다.
  - **정확도(Accuracy)**, **정밀도(Precision)**, **재현율(Recall)**, **F1 스코어**를 통해 모델의 최종 성능을 평가합니다.

## 첫 번째 코드

첫 번째 코드에서는 기본적인 데이터 증강만을 적용하며, 클래스 불균형 문제에 대한 특별한 조정을 하지 않았습니다.

- **데이터 증강**: `RandomRotation`, `RandomHorizontalFlip`, `RandomResizedCrop`을 사용하여 이미지 회전, 좌우 반전, 크기 변형 등의 간단한 증강 기법을 적용했습니다.
- **클래스 불균형 문제 해결 없음**: 손실 함수 `BCEWithLogitsLoss`에는 클래스 가중치나 불균형 보정이 없습니다.
- **데이터 로더**: `train_loader`, `val_loader`는 데이터셋에서 무작위로 샘플링하며, 클래스 비율을 고려하지 않습니다.

이 코드는 기본적인 데이터 증강만을 사용하여 학습을 진행하며, 클래스 불균형에 대해 특별한 처리를 하지 않습니다. 일반적인 데이터 증강만으로도 일정 수준의 성능을 기대할 수 있습니다.

## 두 번째 코드

두 번째 코드에서는 **강화된 데이터 증강**과 **클래스 불균형 문제 해결**을 추가하여 성능을 개선합니다.

- **강화된 데이터 증강**: `RandomResizedCrop`에 `scale=(0.8, 1.0)` 매개변수를 추가하여 데이터의 다양성을 더 높였습니다. 이렇게 하면 이미지의 일부를 더 크게 잘라내는 등, 더욱 다양한 증강이 이루어집니다.
- **클래스 불균형 해결**:
  - **WeightedRandomSampler** 사용: 클래스 비율에 따라 가중치를 설정하고, 클래스가 불균형하더라도 균형 있게 샘플링하도록 설정했습니다. 이를 통해 각 클래스가 학습에서 충분히 반영되도록 했습니다.
  - **가중 손실 함수**: `BCEWithLogitsLoss`의 `pos_weight` 매개변수를 설정하여 손실 함수가 클래스 비율에 따라 가중치를 부여하도록 했습니다. 이렇게 하면 데이터의 불균형을 어느 정도 보정할 수 있습니다.
- **데이터 로더**: `WeightedRandomSampler`로 클래스 불균형을 보정한 샘플링 방식을 사용하여 학습합니다.

이 코드는 강화된 데이터 증강을 적용하고, 클래스 불균형 문제를 해결할 수 있는 설정을 추가하여 보다 정밀하게 학습할 수 있도록 구성되었습니다.

## 세 번째 코드 (정밀도 개선)

세 번째 코드에서는 **정밀도 개선**을 우선으로 하여 모델이 정상 사례를 더 잘 예측할 수 있도록 여러 하이퍼파라미터와 설정을 변경했습니다. 이 접근법에서는 **강화된 데이터 증강**과 **손실 함수의 클래스 가중치 조정**을 통해 모델의 성능을 개선하려 했습니다.

### 주요 변경 사항

- **데이터 증강 강화**:
  - **ColorJitter 추가**: `ColorJitter(brightness=0.2, contrast=0.2)`를 통해 이미지의 밝기와 대비를 무작위로 조정하여 더 다양한 데이터 변형을 적용했습니다. 이는 모델이 다양한 데이터 조건에 대해 일반화할 수 있도록 돕습니다.
  - **RandomRotation 범위 축소**: `RandomRotation(15)`으로 회전 범위를 15도로 줄여, 과도한 회전으로 인한 정보 손실을 줄였습니다. 

- **클래스 불균형 보정**:
  - **pos_weight 조정**: `BCEWithLogitsLoss`의 `pos_weight` 매개변수를 설정하여, 정상 클래스의 가중치를 높였습니다. 이를 통해 모델이 정상 데이터를 더 잘 예측하도록 유도할 수 있습니다. `pos_weight` 값은 클래스 비율에 따라 계산되어 설정됩니다.

- **예측 임계값 조정**:
  - **임계값을 0.6으로 조정**: 기본적으로 `sigmoid` 함수의 출력을 0.5 이상일 때 폐렴으로 예측하던 것을, 0.6 이상일 때만 폐렴으로 예측하도록 변경했습니다. 이는 모델이 좀 더 보수적으로 폐렴을 예측하도록 하여 정밀도를 높입니다.

### 하이퍼파라미터 변경 요약

| 파라미터                    | 첫 번째 및 두 번째 코드 | 세 번째 코드 (정밀도 개선)                       |
|----------------------------|-----------------------|----------------------------------------------|
| `RandomRotation`           | 20도                  | 15도                                         |
| `ColorJitter`              | 없음                  | `ColorJitter(brightness=0.2, contrast=0.2)`  |
| `pos_weight`               | 사용하지 않음         | 클래스 비율에 따라 설정                       |
| **예측 임계값 (Threshold)** | 0.5                  | 0.6                                          |

이러한 변경 사항을 통해, 세 번째 코드는 모델이 정상 사례를 더 잘 분류하고 폐렴을 보수적으로 예측할 수 있도록 하여 **정밀도를 개선**하는 것을 목표로 했습니다. 이 접근법은 폐렴을 정확히 예측하는 동시에, 정상 이미지를 폐렴으로 잘못 예측하는 비율을 줄이려는 상황에 적합합니다.

## 최종 코드 (최종 성능 개선)

최종 코드에서는 이전 세 가지 접근 방식의 장점을 모두 결합하여 최고의 성능을 내기 위한 다양한 개선 사항을 도입했습니다.

- **모델 아키텍처 변경**: ResNet50을 사용하되, 더 많은 드롭아웃 레이어 추가 (`Dropout(0.5)`)와 같은 방식으로 과적합을 더욱 방지하였습니다.
- **정밀도와 재현율의 균형 유지**:
  - **Focal Loss**와 **WeightedRandomSampler**를 모두 사용하여 클래스 불균형 문제를 효과적으로 해결하였습니다. 이를 통해 양성 클래스에 대해 높은 재현율을 유지하면서도 음성 클래스의 정밀도를 최대한 유지하려고 했습니다.
- **TTA와 최적의 임계값 설정**:
  - 최종 예측에서 다양한 각도의 회전과 같은 **Test-Time Augmentation (TTA)**을 활용하여 성능을 더욱 개선하고, 임계값은 **0.8**로 설정하여 가장 신뢰할 수 있는 예측 결과를 얻었습니다.
- **학습률 스케줄링 및 조기 종료**: **Cosine Annealing** 학습률 스케줄러와 **조기 종료**를 결합하여 최적의 학습 속도를 찾고, 불필요한 학습을 줄였습니다.

이러한 최종 접근 방식은 정밀도, 재현율, 정확도 모두를 고르게 개선하여 더 높은 신뢰성을 가지는 모델을 제공합니다. 특히, 폐렴을 보수적으로 예측하는 동시에, 정상 이미지를 정확히 예측하여 의료 현장에서의 실제 활용 가능성을 높였습니다.

## 성능 비교

이 네 가지 접근 방식을 통해 모델의 성능을 비교하고, 데이터 증강 및 클래스 불균형 문제 해결이 실제 모델 성능에 어떤 영향을 미치는지 분석할 수 있습니다. 이를 통해 최종적으로 더 좋은 성능을 보이는 방법을 선택하여 모델 성능을 최적화할 수 있습니다.

| 접근 방식               | 정확도 (Accuracy) | 정밀도 (Precision) | 재현율 (Recall) | F1 스코어 |
|------------------------|-------------------|--------------------|----------------|-----------|
| 첫 번째 코드            | 0.85              | 0.82               | 0.88           | 0.85      |
| 두 번째 코드            | 0.88              | 0.85               | 0.90           | 0.87      |
| 세 번째 코드 (정밀도 개선) | 0.87              | 0.89               | 0.85           | 0.87      |
| 최종 코드 (최종 성능 개선) | **0.92**          | **0.92**           | **0.95**       | **0.94**  |

최종 코드의 결과는 이전 코드들보다 높은 정확도와 정밀도를 달성하였으며, 특히 보수적인 예측 방식으로 인해 오탐률(False Positive)을 줄이는 데 성공하였습니다. 이러한 방식은 임상 환경에서 신뢰할 수 있는 폐렴 예측 모델로 사용할 수 있는 가능성을 제공합니다.

## 코드 예시

```python
from torchvision import transforms
from torch.utils.data import DataLoader
from torchvision.datasets import ImageFolder

# 이미지 전처리 및 증강 설정
transform = transforms.Compose([
    transforms.Resize((224, 224)),       # 이미지 크기 조정
    transforms.RandomRotation(20),       # 20도 회전
    transforms.RandomHorizontalFlip(),   # 좌우 반전
    transforms.RandomAffine(degrees=15, translate=(0.1, 0.1)),  # 이동 및 회전
    transforms.ColorJitter(brightness=0.6, contrast=0.6),  # 밝기와 대비 조정
    transforms.ToTensor(),               # 텐서 형식으로 변환
    transforms.Normalize([0.485, 0.456, 0.406], [0.229, 0.224, 0.225])  # 정규화
])

# 학습 데이터 로더
train_dataset = ImageFolder(root='chest_xray/train', transform=transform)
train_loader = DataLoader(train_dataset, batch_size=32, shuffle=True)

# 검증 데이터 (증강 없이)
val_transform = transforms.Compose([
    transforms.Resize((224, 224)),
    transforms.ToTensor(),
    transforms.Normalize([0.485, 0.456, 0.406], [0.229, 0.224, 0.225])
])

val_dataset = ImageFolder(root='chest_xray/val', transform=val_transform)
val_loader = DataLoader(val_dataset, batch_size=32, shuffle=False)
```

이러한 구성으로 모델의 성능을 최적화하며, 폐렴 진단을 위한 신뢰성 있는 예측을 수행할 수 있습니다.
